{"version":"8a409ed5c20d2591","fileName":"HashMap.java","fileSimpleName":"HashMap","fileType":"java","notes":{"640":"遍历到末尾，现在链表尾部添加该节点","2177":"否则将红黑树头节点作为新索引位置的元素","642":"遍历的链表节点数大于 8 时，将链表转为红黑树","647":"遍历时发现节点 e 与 待插入的元素有相同的 hash 和 key，停止遍历， e 已经记录了该节点","652":"记录到了具有相同元素的节点","656":"空函数，可以根据需要进行覆盖","661":"当 结点数+1 大于 threshold 时，扩容","663":"空函数，根据需要覆盖","678":"获得扩容前的数组长度和最大容量","682":"如果超过了数组的最大容量就不能再扩容了，直接返回原来的 table，冲突也没办法","686":"长度和最大容量都扩容为原来的二倍","701":"更新新的最大容量为扩容后计算的最大容量","703":"更新扩容后的新数组长度","706":"遍历老数组下标索引","708":"如果老数组对应索引上有元素则取出链表头节点放在 e 中","709":"把老数组 j 下标位置置为空，方便回收","710":"如果老数据 j 下标处只有头节点一个元素，则直接计算新数组中位置放置","713":"如果是红黑树结构则单独处理","714":"能进来这个地方，说明头节点后面还有节点，j 下标位置存在哈希冲突的链表结构","715":"用于处理原索引位置的节点","716":"用于处理 原索引 + 扩容前的数据长度 位置处节点","718":"循环处理链表上的每个元素","720":"判断 key 的 （hash 值与老数组长度 与操作后）结果决定是放在原索引处还是新索引，为 0 代表放在原索引处，为 1 代表放在 原索引 + 扩容前的数组","336":"当 key \u003d null，hash 值为 0，所以 HashMap 的 key 可以为 null","721":"如果原索引处为空，创建新链表","337":"HashTable 对 key 直接 hashCode()，若 key 为 null，会抛出异常，所以 HashTable 的 key 不能为空","338":"当 key !\u003d null 时，先计算出 key 的 hashCode()，然后对哈希码进行扰动处理：按位 异或(^) 哈希码自身右移 16 位后的二进制","724":"如果原索引处有链表了，把元素追加在链表后面","727":"在新索引（原索引 + oldCap）处建立新的链表","2136":"针对扩容处理红黑树的方法","2137":"红黑树的 hash 分布，只可能存在两个位置：原索引位置，原索引位置 + oldCap","2138":"拿到调用此方法的节点赋给 b 节点","2140":"存储索引位置为：\"原索引位置的节点\"","2141":"存储索引位置为：\"原索引 + oldCap\" 的节点","734":"通过 do 方法体里已经判断出了到底是原索引位置处添加 还是在 原索引 + 原数组长度处 添加","2142":"以调用此方法的节点开始，遍历整个红黑树的节点","2143":"从 b 节点开始遍历","736":"放入原索引处 loTail.next \u003d null","2144":"next 赋值为 e 的下个节点","2145":"将老链表的 next 节点设为空，让垃圾收集器回收","2146":"e 的哈希值与老表容量与运算结果为 0 ，扩容后的索引位置跟老表的索引位置一致","2147":"如果 loTial 为空，代表该节点为第一个节点","2148":"将 e 作为第一个节点赋值给 loHead","740":"放入新索引处","2150":"否则将节点添加到 loTail 后面","2151":"将 loTail 赋值为新的节点","2152":"统计原索引位置节点个数","2154":"如果 e 的哈希值与老表容量与运算结果为 1，则扩容后的索引位置为：老表的索引位置 + oldCap","2155":"如果 hiTail 为空，代表该节点为第一个节点","2156":"将 e 作为第一个节点赋值给 hiHead","2158":"否则将节点添加到 hiTail 后面","2159":"将 hiTail 赋值为新的节点","2160":"统计索引位置为 原索引 + oldCap 的节点个数","627":"如果 table 为空，或者还没有元素，则扩容","756":"先检查 table 的长度是否小于 64","2164":"如果原索引位置不为空","757":"扩容","2165":"如果节点个数 \u003c\u003d 6 则将红黑树转为链表","629":"(n-1) \u0026 hash 算出 table 的 Index\n如果 table[index] 为空，代表 index 还没有创建链表的头链表，需要先创建头节点","758":"否则将链表转换为红黑树","631":"说明当前节点有值，碰撞了","2168":"将原索引位置的节点设置为头节点","2169":"如果 hiHead 不为空，则代表原来的红黑树（老表中的红黑树节点被分到了两个位置）已经被改变，需要重新构建红黑树","634":"如果在首节点和待插入的元素 有相同的 hash 值 和 key 先记录下来","2170":"以 loHead 为根节点，构建红黑树","636":"如果首节点的类型为红黑树，则按照红黑树的方法添加元素","2173":"如果 新索引位置不为空","638":"首节点为链表类型","2174":"新索引位置节点个数 \u003c\u003d 6， 转化为链表"}}