{"version":"f830af3574857f3f","fileName":"HashMap.java","fileSimpleName":"HashMap","fileType":"java","notes":{"641":"遍历到链表末尾，添加元素","643":"遍历时如果链表长度大于 8 时，将链表转换为红黑树","707":"遍历老数组下标","709":"如果老数组下标对应位置有元素则取出该元素（链表头节点） 放入 e 中","710":"把老数组该下标位置置为空，方便 JVM 回收","711":"如果老数组 j 下标位置只有 头节点 一个元素，，则直接通过 hash \u0026 （length - 1）计算该元素的位置在新数组中的位置并放入","648":"遍历时发现节点 e 和 待插入元素有相同的 hash 和 key 值，停止遍历，代表链表中已经存在 待插入元素","713":"如果头节点是红黑树类型的，则另外处理","715":"进来这个逻辑，说明头节点后面还有节点，j 下标位置存在哈希冲突的链表结构","716":"用于处理 （原索引） 位置的节点","653":"已经有 待插入元素相同的 key 了","717":"用于处理 （原索引下标 + 扩容前的数组长度） 位置处节点","719":"循环处理链表上的每一个元素","721":"判断 （key 的 hash 值 \u0026 老数组长度）结果，为 0 代表放在（原索引）处，为 1 代表放在 （原索引 + oldCap）处下标","722":"如果原索引处为空，把 待插入元素 作为头节点","725":"如果不为空，把 待插入元素 追加到链表后面","662":"如果 结点数 + 1 大于 threshold 时，扩容","664":"空函数，完成元素插入时的自定义操作，根据需要在子类重写","728":"在新索引 （原索引 + oldCap）处建立新的链表","734":"通过 do 代码块已经判断出了到底是在 （原索引） 下标处添加还是在 （原索引 + oldCap）下标处添加","679":"获得扩容前的数组长度和最大容量","683":"如果超过了数组的最大容量就不能再扩容了，直接返回原来的 table，发生冲突也没办法","687":"长度和最大容量都扩容为原来的两倍","691":"当前 table 为空，初始化 table 长度为阈值","628":"如果 table 为空， 或者 table 里还没有元素，则进行扩容","693":"如果阈值为 0，则使用默认的容量值来初始化 table 数组","630":"(n - 1) \u0026 hash 算出 table 的 Index 值，如果 table[index] 为空，代表 table[index] 处还没有创建链表的头节点，需要先创建头节点","632":"说明 table[index] 已经有头节点在了，hash 碰撞了","635":"如果头节点 和 待插入的元素 有相同的 hash 值和 key 值，先保存下来","637":"如果头节点的类型为红黑树，则按照红黑树的方法添加 待插入元素","702":"更新新的最大容量为扩容后计算的最大容量","639":"头节点为链表类型"}}