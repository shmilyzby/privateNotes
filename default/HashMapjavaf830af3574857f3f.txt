{"version":"f830af3574857f3f","fileName":"HashMap.java","fileSimpleName":"HashMap","fileType":"java","notes":{"2176":"统计原索引位置已添加到新位置的节点个数","641":"遍历到链表末尾，添加元素","2178":"如果 e 的哈希值与老表容量与运算结果为 1，则扩容后的索引位置为：老表的索引位置 + oldCap","643":"遍历时如果链表长度大于 8 时，将链表转换为红黑树","2179":"如果 hiTail 为空，代表待插入节点节点为第一个节点","2180":"把 e 赋给 hiHead，标记尾链表头节点","2182":"hiTail 不为空，把 e 追加到链表尾部","2183":"把 e 赋值给 hiTail，标记为链表的尾节点","648":"遍历时发现节点 e 和 待插入元素有相同的 hash 和 key 值，停止遍历，代表链表中已经存在 待插入元素","2184":"统计已经添加到索引位置为 原索引 + oldCap 的节点个数","2188":"如果是添加到了 原索引位置","653":"已经有 待插入元素相同的 key 了","2189":"如果节点个数 \u003c\u003d 6 则将红黑树转为链表","2192":"将原索引位置的节点设置为头节点","2193":"如果 hiHead 不为空，则代表原来的红黑树（老表中的红黑树节点被分到了两个位置）已经被改变，需要重新构建红黑树","2194":"以 loHead 为根节点，构建红黑树","2197":"如果是添加到了 原索引 + oldCap 位置","662":"如果 结点数 + 1 大于 threshold 时，扩容","2198":"新索引位置节点个数 \u003c\u003d 6， 转化为链表","664":"空函数，完成元素插入时的自定义操作，根据需要在子类重写","2202":"否则将红黑树头节点作为新索引位置的元素","679":"获得扩容前的数组长度和最大容量","683":"如果超过了数组的最大容量就不能再扩容了，直接返回原来的 table，发生冲突也没办法","687":"长度和最大容量都扩容为原来的两倍","691":"当前 table 为空，初始化 table 长度为阈值","693":"如果阈值为 0，则使用默认的容量值来初始化 table 数组","702":"更新新的最大容量为扩容后计算的最大容量","707":"遍历老数组下标","709":"如果老数组下标对应位置有元素则取出该元素（链表头节点） 放入 e 中","710":"把老数组该下标位置置为空，方便 JVM 回收","711":"如果老数组 j 下标位置只有 头节点 一个元素，，则直接通过 hash \u0026 （length - 1）计算该元素的位置在新数组中的位置并放入","713":"如果头节点是红黑树类型的，则另外处理","715":"进来这个逻辑，说明头节点后面还有节点，j 下标位置存在哈希冲突的链表结构","716":"用于处理 （原索引） 位置的节点","717":"用于处理 （原索引下标 + 扩容前的数组长度） 位置处节点","719":"循环处理链表上的每一个元素","721":"判断 （key 的 hash 值 \u0026 老数组长度）结果，为 0 代表放在（原索引）处，为 1 代表放在 （原索引 + oldCap）处下标","337":"当 key 为 null 时，hash 值为 0， 所以 HashMap 的 key 可以为空","722":"如果原索引处为空，把 待插入元素 作为头节点","338":"HashTable 对 key 直接 hashCode()，若 key 为 null，会直接抛出异常，所以 HashTable 的 key 不能为空","339":"当 key !\u003d null 时，先计算出 key 的 hashCode()，然后对哈希码进行扰动处理","340":"扰动处理：按位 异或（^）哈希码自身右移 16 位后的二进制，其目的是为了让哈希码的高位参与运算","725":"如果不为空，把 待插入元素 追加到链表后面","728":"在新索引 （原索引 + oldCap）处建立新的链表","734":"通过 do 代码块已经判断出了到底是在 （原索引） 下标处添加还是在 （原索引 + oldCap）下标处添加","2161":"红黑树的 hash 分布，只存在两个位置：原索引位置 或 原索引位置 + oldCap","2162":"拿到调用此方法的节点赋给 b 节点","628":"如果 table 为空， 或者 table 里还没有元素，则进行扩容","2164":"存储索引位置为：\"原索引 + oldCap\" 的节点","757":"先检查 tab 的长度是否小于 64","2165":"存储索引位置为：\"原索引 + oldCap\" 的节点","630":"(n - 1) \u0026 hash 算出 table 的 Index 值，如果 table[index] 为空，代表 table[index] 处还没有创建链表的头节点，需要先创建头节点","2166":"以调用此方法的节点开始，遍历整个红黑树的节点","759":"如果大于，将链表转换为红黑树","2167":"从 b 节点开始遍历","632":"说明 table[index] 已经有头节点在了，hash 碰撞了","2168":"next 赋值为 e 的下个节点","2169":"将老链表的下个节点设为空，方便让垃圾收集器回收","2170":"e 的哈希值与 oldCap 与运算（\u0026） 的结果为 0 ，扩容后该元素的索引位置跟老表的索引位置一致","635":"如果头节点 和 待插入的元素 有相同的 hash 值和 key 值，先保存下来","2171":"如果 loTial 为空，代表该节点为第一个节点","2172":"将 e 赋给 loHead 作为头节点","637":"如果头节点的类型为红黑树，则按照红黑树的方法添加 待插入元素","2174":"否则将节点添加到 loTail 后面","639":"头节点为链表类型","2175":"将 e 赋给 loTail，标记为链表的尾节点"}}