{"version":"9d8d88a62dc9a48d","fileName":"ReentrantReadWriteLock.java","fileSimpleName":"ReentrantReadWriteLock","fileType":"java","notes":{"469":"读锁不被 block","470":"加锁次数小于最大值","471":"进行读锁的加锁，state + 1","472":"如果读锁次数为 0 说明当前线程为第一个读的","475":"如果读锁不为 0，但当前线程是第一个读的线程，说明是重入读的","477":"如果读锁不为  0，并且第一个读的线程不是当前线程，说明有多个线程有读锁","391":"获得当前线程","392":"获得状态","393":"获取写线程数","394":"state 不为 0，说明当前有读锁或写锁或者两者都有","396":"如果 w 为 0，说明没有写锁，只有读锁，或者当前执行线程不是该线程，两者满足其一，加锁失败","398":"如果写锁重入的次数大于最大容量，抛出异常","463":"获取线程","464":"获取状态","401":"如果上面状态判断都没有进入，说明当前为重入的情况，进行 state 加一","465":"当前有写锁且获得写锁的线程不为当前线程，获取读锁失败，返回 -1","404":"如果 state 为 0，当前没有锁","468":"获取读锁的数值","405":"CAS 状态加一，加锁","406":"争抢失败，返回 false","407":"争抢成功，设置自己为当前执行的线程"}}

